TODO
+ IsNeedInit() 메소드 내부로직 수정
+ ECSManager 테스트 코드 완성
+ ECSCore 리펙토링
+ ECSManager 의 public 를 제외한 모든 접근제한자 internal로 변경
+ ECSManager(World)에서 AddComponent(entitiy, T , newtypeData)를 생성. 
	엔티티를 기준으로 타입을 추가한다. 그리고 새로운아키타입 할당.
	기존데이터 할당, 새로운타입의 데이터 할당.
+ 컴포넌트 타입의 중복배열에서 정렬까지 할당 (현재는 아키타입에서 정렬중.)
	컴포넌트타입들의 구성을 기반으로 해쉬값을 생성해, 아키타입딕셔너리의 키값으로 사용하는데 정렬순서도 해쉬값에 영향이 간다는걸 알았다.
	그래서 입구에서부터 정렬하여 내부는 무결한데이터만 가지고 관리할 수 있게 해야한다.
-------------------------------------------------------------------------------------------------------------
2026-02-15
+ Today
	1. ECSManagerTest.cs 작성
		* InitTest 테스트 완성 (비정상 엔티티 초기화 ->유효성 검사 , 초기화 대상이 아닌 엔티티 걸러내기(IsNeedInit), 정상 엔티티 초기화 -> 유효성 검사)
		* GetTest 테스트 완성 (엔티티 생성후 ref를 사용해 참조로 직접 청크값에 대입해 값변경 확인)
	2. 시스템에 속한 컴포넌트타입들을 정렬한 로직 수정
		* ComponentTypeID class삭제 
			아키타입의 TypeIndexMap의 키로 사용하기위해 클래스를 구성해 사용했지만, 의미가 없었다.
			미리 정수형으로 매핑을 했기에 그냥 그자체를 키값으로 사용하면 되는것.
		* Archetype.cs - Dictionary<ComponentTypeID,int> TypeIndexMap -> Dictionary<int,int> TypeIndexMap
			위와 같은 내용.
		* Archetype.cs - IsNeedInit() 수정
			정수형을 비교함으로써 코드를 좀더 간결하고 직관적이게 바꾸었다.
		* ECSManager.cs - Get<T>() 수정
			기존의 딕셔너리 키 값으로 선언한 클래스를 찾기위해 new로 비교했던 부분을 매핑된 정수형으로 찾는 로직으로 변경했다.
			딕셔너리는 HashCode 와 Equals로 구분하는데 동적할당한 객체를 기존키와 비교했을때 당연히 옳바른 비교가 가능할리 없었다.
			또한 좀 더 직관적인 코드가 되었다.
		* ECSManager.cs - 모든 진입부분 - 타입 중복 예외 
			타입을 제공받는부분에서 한가지 놓친게 있었다.
			"중복의 타입" ECS에서는 중복의 타입을 허용하는게 큰 문제라고 생각한다. 어찌되었든 틀은 비슷해도 다르다고 생각한다.
			그래서 제공받는 ECSManager.cs(World) - IsTypeDublication()에서 제어를 한다.
			생성,추가 관련된 모든부분에서 검사를 진행한다.
			
-------------------------------------------------------------------------------------------------------------
2026-02-14
+ 깃 리포지트리 정리. 
	깃에 익숙하지 않아 파일정리 하느라 기존 리포지트리를 날렸다. 
	코드 변경은 올라가있지 않았던 테스트 코드 프로젝트를 추가해서 올린것 말곤 변경한게 없다.
-------------------------------------------------------------------------------------------------------------
2026-02-12
+ Today
	ECSManager 테스트 코드 작성 (ECSManagerTest.cs)
+ Trobule
	테스트 코드 작성중 NeedInit컴포넌트 의 존재 유무 비교하는 IsNeedInit() 문제가 생김. (ECSManager.cs) - 해결
		Archetype에 포함된 타입들을 ComponentTypeID를 키, int 를 값으로 갖는 TypeIndexMap이라는
		딕셔너리로 관리하고 있었다. 기존에는 TryGetValue메소드를 사용해 비교를 했다.
		값을 비교하기 위해 집어넣어주는 ComponenetTypeID를 new로 NeedInit의 아이디를 주며 할당했는데
		사실 이둘은 전혀 다른 메모리에 저장된 다른객체가 된다. 그래서 항상 false를 반환하게 된다.
		임시로 반복문을 사용해 ComponentTypeID 내부의 ID값과 미리매핑해놓은 NeedInit타입의 ID를 비교하여 
		임시로 해결했다. 반복문으로 딕셔너리전체를 비교해야 한다는게 맘에 들지 않는다. 
		추후, 수정 하려한다.


